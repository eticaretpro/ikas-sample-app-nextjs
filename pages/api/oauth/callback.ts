import type { NextApiRequest, NextApiResponse } from 'next';
import { OAuthAPI, WebhookScope } from '@ikas/api-client';
import nc from 'next-connect';
import moment from 'moment';
import { AuthToken, RedisDB } from '../../../lib/redis';
import { config } from '../../../globals/config';
import { getIkas } from '../../../lib/ikas-api';
import { ApiErrorResponse } from '../../../globals/types';

type CallbackApiRequest = {
  storeName: string;
  code: string;
  state: string;
};

type CallbackApiResponse = ApiErrorResponse;

/**
 * OAuth callback API. This API is called when a merchant accepts to install the app to his/her store.
 * You need to check the state variable if it is generated by your app before proceeding.
 */
const handler = nc<NextApiRequest, NextApiResponse<CallbackApiResponse>>().get(async (req, res) => {
  try {
    // Validate if code, storeName and state exists on req.query
    if (!req.query.code) res.status(400).json({ statusCode: 400, message: 'code is required' });
    if (!req.query.storeName) res.status(400).json({ statusCode: 400, message: 'storeName is required' });
    if (!req.query.state) res.status(400).json({ statusCode: 400, message: 'state is required' });

    const { code, storeName, state } = req.query as CallbackApiRequest;

    // load your saved state variable from a temporary key-value database
    // like Redis, Memcached and validate it
    let savedState = await RedisDB.state.get(state);

    if (state == savedState) {
      // OAuthAPI.getTokenWithAuthorizationCode send code to ikas
      // and retrieve access token and refresh token
      const codeResponse = await OAuthAPI.getTokenWithAuthorizationCode(
        {
          code,
          client_id: config.appId,
          client_secret: config.appSecret,
          redirect_uri: config.callbackUrl,
        },
        {
          storeName,
        },
      );

      if (codeResponse && codeResponse.status == 200 && codeResponse.data) {
        const expireDate = moment().add(codeResponse.data.expires_in, 'seconds').toDate().toISOString();

        const token: AuthToken = {
          ...codeResponse.data,
          expireDate,
          authorizedAppId: '',
        };

        const ikas = getIkas(token);
        const meResponse = await ikas.adminApi.queries.me({});

        if (meResponse.isSuccess && meResponse.data) {
          token.authorizedAppId = meResponse.data.id!;

          // Save token to db, so you can use it later
          await RedisDB.token.set(token.authorizedAppId, token);

          // Register your app for product create webhooks
          const webhookRes = await ikas.adminApi.mutations.saveWebhook({
            variables: {
              input: {
                endpoint: `${config.deployUrl}/api/ikas/webhook`,
                scopes: [WebhookScope.PRODUCT_CREATED],
              },
            },
          });

          if (!webhookRes.isSuccess) console.error('Webhook save error', webhookRes.error || webhookRes.errors);

          // Redirect back to ikas admin dashboard
          res.redirect(`https://${storeName}.myikas.com/admin/authorized-app/${token.authorizedAppId}`);
          return;
        }
      }
    }

    res.redirect(`/authorize-store?storeName=${storeName}&status=fail`);
  } catch (err: any) {
    res.status(500).json({ statusCode: 500, message: err.message });
  }
});

export default handler;
